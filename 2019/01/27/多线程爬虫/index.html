<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>多线程爬虫 | langke Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">langke&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                

            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">langke&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div id="post-toc" class="post-toc">
            <span class="post-toc-title">catalogue</span>
            <div class="post-toc-content">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#爬虫教程"><span class="toc-text">爬虫教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程爬虫"><span class="toc-text">多线程爬虫</span></a></li></ol></li></ol>
            </div>
        </div>
    
    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">多线程爬虫</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        Date: <a href="#">01 27&nbsp;&nbsp;17:53:12</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <section class="post-content">
            <h1 id="爬虫教程"><a href="#爬虫教程" class="headerlink" title="爬虫教程"></a>爬虫教程</h1><h2 id="多线程爬虫"><a href="#多线程爬虫" class="headerlink" title="多线程爬虫"></a>多线程爬虫</h2><a id="more"></a>
<p>有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用之前那种同步的方式下载。那效率肯会特别慢。这时候我们就可以考虑使用多线程的方式来下载图片。</p>
<p><strong>多线程介绍：</strong><br>多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。<br>最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也可以有多节车厢。多线程的出现就是为了提高效率。同时它的出现也带来了一些问题。更多介绍请参考：<a href="https://baike.baidu.com/item/多线程/1190404?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/多线程/1190404?fr=aladdin</a></p>
<p><strong>threading模块介绍：</strong><br>threading模块是python中专门提供用来做多线程编程的模块。threading模块中最常用的类是Thread。以下看一个简单的多线程程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def coding():</span><br><span class="line">    for x in range(3):</span><br><span class="line">        print(&apos;%s正在写代码&apos; % x)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">def drawing():</span><br><span class="line">    for x in range(3):</span><br><span class="line">        print(&apos;%s正在画图&apos; % x)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def single_thread():</span><br><span class="line">    coding()</span><br><span class="line">    drawing()</span><br><span class="line"></span><br><span class="line">def multi_thread():</span><br><span class="line">    t1 = threading.Thread(target=coding)</span><br><span class="line">    t2 = threading.Thread(target=drawing)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure>
<p><strong>查看线程数：</strong><br>使用threading.enumerate()函数便可以看到当前线程的数量。</p>
<p><strong>查看当前线程的名字：</strong><br>使用threading.current_thread()可以看到当前线程的信息。</p>
<p><strong>继承自threading.Thread类：</strong><br>为了让线程代码更好的封装。可以使用threading模块下的Thread类，继承自这个类，然后实现run方法，线程就会自动运行run方法中的代码。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class CodingThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        for x in range(3):</span><br><span class="line">            print(&apos;%s正在写代码&apos; % threading.current_thread())</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line">class DrawingThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        for x in range(3):</span><br><span class="line">            print(&apos;%s正在画图&apos; % threading.current_thread())</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line">def multi_thread():</span><br><span class="line">    t1 = CodingThread()</span><br><span class="line">    t2 = DrawingThread()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure></p>
<p><strong>多线程共享全局变量的问题：</strong><br>多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。比如以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">tickets = 0</span><br><span class="line"></span><br><span class="line">def get_ticket():</span><br><span class="line">    global tickets</span><br><span class="line">    for x in range(1000000):</span><br><span class="line">        tickets += 1</span><br><span class="line">    print(&apos;tickets:%d&apos;%tickets)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    for x in range(2):</span><br><span class="line">        t = threading.Thread(target=get_ticket)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>以上结果正常来讲应该是6，但是因为多线程运行的不确定性。因此最后的结果可能是随机的。</p>
<p><strong>锁机制：</strong><br>为了解决以上使用共享全局变量的问题。threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，直到当前线程处理完后，把锁释放了，其他线程才能进来处理。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">VALUE = 0</span><br><span class="line"></span><br><span class="line">gLock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def add_value():</span><br><span class="line">    global VALUE</span><br><span class="line">    gLock.acquire()</span><br><span class="line">    for x in range(1000000):</span><br><span class="line">        VALUE += 1</span><br><span class="line">    gLock.release()</span><br><span class="line">    print(&apos;value：%d&apos;%VALUE)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    for x in range(2):</span><br><span class="line">        t = threading.Thread(target=add_value)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>Lock版本生产者和消费者模式：</strong><br>生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。以下是使用threading.Lock锁实现的“生产者与消费者模式”的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import random</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">gMoney = 1000</span><br><span class="line">gLock = threading.Lock()</span><br><span class="line"># 记录生产者生产的次数，达到10次就不再生产</span><br><span class="line">gTimes = 0</span><br><span class="line"></span><br><span class="line">class Producer(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global gMoney</span><br><span class="line">        global gLock</span><br><span class="line">        global gTimes</span><br><span class="line">        while True:</span><br><span class="line">            money = random.randint(100, 1000)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            # 如果已经达到10次了，就不再生产了</span><br><span class="line">            if gTimes &gt;= 10:</span><br><span class="line">                gLock.release()</span><br><span class="line">                break</span><br><span class="line">            gMoney += money</span><br><span class="line">            print(&apos;%s当前存入%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class="line">            gTimes += 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line">class Consumer(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global gMoney</span><br><span class="line">        global gLock</span><br><span class="line">        global gTimes</span><br><span class="line">        while True:</span><br><span class="line">            money = random.randint(100, 500)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            if gMoney &gt; money:</span><br><span class="line">                gMoney -= money</span><br><span class="line">                print(&apos;%s当前取出%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class="line">                time.sleep(0.5)</span><br><span class="line">            else:</span><br><span class="line">                # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下</span><br><span class="line">                if gTimes &gt;= 10:</span><br><span class="line">                    gLock.release()</span><br><span class="line">                    break</span><br><span class="line">                print(&quot;%s当前想取%s元钱，剩余%s元钱，不足！&quot; % (threading.current_thread(),money,gMoney))</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    for x in range(5):</span><br><span class="line">        Consumer(name=&apos;消费者线程%d&apos;%x).start()</span><br><span class="line"></span><br><span class="line">    for x in range(5):</span><br><span class="line">        Producer(name=&apos;生产者线程%d&apos;%x).start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>Condition版的生产者与消费者模式：</strong><br>Lock版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过while True死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。首先对threading.Condition相关的函数做个介绍，threading.Condition类似threading.Lock，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下将一些常用的函数做个简单的介绍：</p>
<p>acquire：上锁。<br>release：解锁。<br>wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。<br>notify：通知某个正在等待的线程，默认是第1个等待的线程。<br>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。<br>Condition版的生产者与消费者模式代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import random</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">gMoney = 1000</span><br><span class="line">gCondition = threading.Condition()</span><br><span class="line">gTimes = 0</span><br><span class="line">gTotalTimes = 5</span><br><span class="line"></span><br><span class="line">class Producer(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global gMoney</span><br><span class="line">        global gCondition</span><br><span class="line">        global gTimes</span><br><span class="line">        while True:</span><br><span class="line">            money = random.randint(100, 1000)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            if gTimes &gt;= gTotalTimes:</span><br><span class="line">                gCondition.release()</span><br><span class="line">                print(&apos;当前生产者总共生产了%s次&apos;%gTimes)</span><br><span class="line">                break</span><br><span class="line">            gMoney += money</span><br><span class="line">            print(&apos;%s当前存入%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class="line">            gTimes += 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line">            gCondition.notify_all()</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line">class Consumer(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global gMoney</span><br><span class="line">        global gCondition</span><br><span class="line">        while True:</span><br><span class="line">            money = random.randint(100, 500)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            # 这里要给个while循环判断，因为等轮到这个线程的时候</span><br><span class="line">            # 条件有可能又不满足了</span><br><span class="line">            while gMoney &lt; money:</span><br><span class="line">                if gTimes &gt;= gTotalTimes:</span><br><span class="line">                    gCondition.release()</span><br><span class="line">                    return</span><br><span class="line">                print(&apos;%s准备取%s元钱，剩余%s元钱，不足！&apos;%(threading.current_thread(),money,gMoney))</span><br><span class="line">                gCondition.wait()</span><br><span class="line">            gMoney -= money</span><br><span class="line">            print(&apos;%s当前取出%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    for x in range(5):</span><br><span class="line">        Consumer(name=&apos;消费者线程%d&apos;%x).start()</span><br><span class="line"></span><br><span class="line">    for x in range(2):</span><br><span class="line">        Producer(name=&apos;生产者线程%d&apos;%x).start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>Queue线程安全队列：</strong><br>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做queue模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下：</p>
<p>初始化Queue(maxsize)：创建一个先进先出的队列。<br>qsize()：返回队列的大小。<br>empty()：判断队列是否为空。<br>full()：判断队列是否满了。<br>get()：从队列中取最后一个数据。<br>put()：将一个数据放到队列中。<br>使用生产者与消费者模式多线程下载表情包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line">from urllib import request</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">class Producer(threading.Thread):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    def __init__(self,page_queue,img_queue,*args,**kwargs):</span><br><span class="line">        super(Producer, self).__init__(*args,**kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if self.page_queue.empty():</span><br><span class="line">                break</span><br><span class="line">            url = self.page_queue.get()</span><br><span class="line">            self.parse_page(url)</span><br><span class="line"></span><br><span class="line">    def parse_page(self,url):</span><br><span class="line">        response = requests.get(url,headers=self.headers)</span><br><span class="line">        text = response.text</span><br><span class="line">        html = etree.HTML(text)</span><br><span class="line">        imgs = html.xpath(&quot;//div[@class=&apos;page-content text-center&apos;]//a//img&quot;)</span><br><span class="line">        for img in imgs:</span><br><span class="line">            if img.get(&apos;class&apos;) == &apos;gif&apos;:</span><br><span class="line">                continue</span><br><span class="line">            img_url = img.xpath(&quot;.//@data-original&quot;)[0]</span><br><span class="line">            suffix = os.path.splitext(img_url)[1]</span><br><span class="line">            alt = img.xpath(&quot;.//@alt&quot;)[0]</span><br><span class="line">            alt = re.sub(r&apos;[，。？?,/\\·]&apos;,&apos;&apos;,alt)</span><br><span class="line">            img_name = alt + suffix</span><br><span class="line">            self.img_queue.put((img_url,img_name))</span><br><span class="line"></span><br><span class="line">class Consumer(threading.Thread):</span><br><span class="line">    def __init__(self,page_queue,img_queue,*args,**kwargs):</span><br><span class="line">        super(Consumer, self).__init__(*args,**kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if self.img_queue.empty():</span><br><span class="line">                if self.page_queue.empty():</span><br><span class="line">                    return</span><br><span class="line">            img = self.img_queue.get(block=True)</span><br><span class="line">            url,filename = img</span><br><span class="line">            request.urlretrieve(url,&apos;images/&apos;+filename)</span><br><span class="line">            print(filename+&apos;  下载完成！&apos;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    page_queue = Queue(100)</span><br><span class="line">    img_queue = Queue(500)</span><br><span class="line">    for x in range(1,101):</span><br><span class="line">        url = &quot;http://www.doutula.com/photo/list/?page=%d&quot; % x</span><br><span class="line">        page_queue.put(url)</span><br><span class="line"></span><br><span class="line">    for x in range(5):</span><br><span class="line">        t = Producer(page_queue,img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    for x in range(5):</span><br><span class="line">        t = Consumer(page_queue,img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p><strong>GIL全局解释器锁：</strong><br>Python自带的解释器是CPython。CPython解释器的多线程实际上是一个假的多线程（在多核CPU中，只能利用一核，不能利用多核）。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中有一个东西叫做GIL（Global Intepreter Lock），叫做全局解释器锁。这个解释器锁是有必要的。因为CPython解释器的内存管理不是线程安全的。当然除了CPython解释器，还有其他的解释器，有些解释器是没有GIL锁的，见下面：</p>
<p>Jython：用Java实现的Python解释器。不存在GIL锁。更多详情请见：<a href="https://zh.wikipedia.org/wiki/Jython" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Jython</a><br>IronPython：用.net实现的Python解释器。不存在GIL锁。更多详情请见：<a href="https://zh.wikipedia.org/wiki/IronPython" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/IronPython</a><br>PyPy：用Python实现的Python解释器。存在GIL锁。更多详情请见：<a href="https://zh.wikipedia.org/wiki/PyPy" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/PyPy</a><br>GIL虽然是一个假的多线程。但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。<br>多线程下载百思不得姐段子作业：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line">import threading</span><br><span class="line">from queue import Queue</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BSSpider(threading.Thread):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    def __init__(self,page_queue,joke_queue,*args,**kwargs):</span><br><span class="line">        super(BSSpider, self).__init__(*args,**kwargs)</span><br><span class="line">        self.base_domain = &apos;http://www.budejie.com&apos;</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.joke_queue = joke_queue</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if self.page_queue.empty():</span><br><span class="line">                break</span><br><span class="line">            url = self.page_queue.get()</span><br><span class="line">            response = requests.get(url, headers=self.headers)</span><br><span class="line">            text = response.text</span><br><span class="line">            html = etree.HTML(text)</span><br><span class="line">            descs = html.xpath(&quot;//div[@class=&apos;j-r-list-c-desc&apos;]&quot;)</span><br><span class="line">            for desc in descs:</span><br><span class="line">                jokes = desc.xpath(&quot;.//text()&quot;)</span><br><span class="line">                joke = &quot;\n&quot;.join(jokes).strip()</span><br><span class="line">                link = self.base_domain+desc.xpath(&quot;.//a/@href&quot;)[0]</span><br><span class="line">                self.joke_queue.put((joke,link))</span><br><span class="line">            print(&apos;=&apos;*30+&quot;第%s页下载完成！&quot;%url.split(&apos;/&apos;)[-1]+&quot;=&quot;*30)</span><br><span class="line"></span><br><span class="line">class BSWriter(threading.Thread):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self, joke_queue, writer,gLock, *args, **kwargs):</span><br><span class="line">        super(BSWriter, self).__init__(*args, **kwargs)</span><br><span class="line">        self.joke_queue = joke_queue</span><br><span class="line">        self.writer = writer</span><br><span class="line">        self.lock = gLock</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                joke_info = self.joke_queue.get(timeout=40)</span><br><span class="line">                joke,link = joke_info</span><br><span class="line">                self.lock.acquire()</span><br><span class="line">                self.writer.writerow((joke,link))</span><br><span class="line">                self.lock.release()</span><br><span class="line">                print(&apos;保存一条&apos;)</span><br><span class="line">            except:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    page_queue = Queue(10)</span><br><span class="line">    joke_queue = Queue(500)</span><br><span class="line">    gLock = threading.Lock()</span><br><span class="line">    fp = open(&apos;bsbdj.csv&apos;, &apos;a&apos;,newline=&apos;&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">    writer = csv.writer(fp)</span><br><span class="line">    writer.writerow((&apos;content&apos;, &apos;link&apos;))</span><br><span class="line"></span><br><span class="line">    for x in range(1,11):</span><br><span class="line">        url = &apos;http://www.budejie.com/text/%d&apos; % x</span><br><span class="line">        page_queue.put(url)</span><br><span class="line"></span><br><span class="line">    for x in range(5):</span><br><span class="line">        t = BSSpider(page_queue,joke_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    for x in range(5):</span><br><span class="line">        t = BSWriter(joke_queue,writer,gLock)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
        </section>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        

        <!--
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/python/"># python</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        -->
        <!--
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/02/03/PHP-常见危险函数/">PHP-常见危险函数</a>
            
            
            <a class="next" rel="next" href="/2019/01/21/app中的加密与解密/">app中的加密与解密</a>
            
        </section>
        -->

    </article>
</div>

        </div>
        <!--
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© langke | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    	-->

    	<br>
    	<br>
    	<br>



    </div>
</body>
</html>
