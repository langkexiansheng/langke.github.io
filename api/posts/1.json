{"total":36,"pageSize":10,"pageCount":4,"data":[{"title":"PHP-常见危险函数","slug":"PHP-常见危险函数","date":"2019-02-03T09:43:50.000Z","updated":"2019-02-04T07:55:31.625Z","comments":true,"path":"api/articles/PHP-常见危险函数.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"常见危险函数\"><a href=\"#常见危险函数\" class=\"headerlink\" title=\"常见危险函数\"></a>常见危险函数</h1><h2 id=\"PHP代码执行函数\"><a href=\"#PHP代码执行函数\" class=\"headerlink\" title=\"PHP代码执行函数\"></a>PHP代码执行函数</h2><ul>\n<li>mixed eval(string $code)</li>\n</ul>\n<p>把字符串 $code 作为PHP代码执行<br>很多常见的<code>webshell</code>都是用<code>eval</code>来执行具体操作的<br>比如：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> @<span class=\"keyword\">eval</span>($_POST[<span class=\"string\">'cmd'</span>]);<span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>bool assert( mixed $assertion [, string $description]) </li>\n</ul>\n<p>检查一个断言是否为 FALSE. (把字符串 $assertion 作为PHP代码执行)</p>\n<p>因为大多数杀软把<code>eval</code>列入黑名单了，所以用<code>assert</code>来代替<code>eval</code>来执行具体操作<br>比如：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> $_GET[<span class=\"string\">'a'</span>]($_GET[<span class=\"string\">'b'</span>]);<span class=\"meta\">?&gt;</span></span><br><span class=\"line\">POC:</span><br><span class=\"line\">?a=assert&amp;b=system(<span class=\"string\">'whoami'</span>)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>mixed preg_replace (mixed $pattern, mixed $replacement, mixed $subject [, int $limit=-1[, int &amp;$count]])<br><code>/e</code>修正符使<code>preg_replace()</code>将<code>replacement</code>参数当作<code>PHP</code>代码<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preg_replace(<span class=\"string\">\"/test/e\"</span>, $_GET[h], <span class=\"string\">\"justst ssda\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果我们提交<code>?h=phpinfo()</code>,<code>phpinfo()</code>将会被执行</p>\n<ul>\n<li><p>string create_function (string $args, string $code)<br>创建一个匿名函数，并返回独一无二的函数名。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$newfunc=create_function(<span class=\"string\">'$v'</span>, <span class=\"string\">'return system($v);'</span>);</span><br><span class=\"line\">$newfunc(<span class=\"string\">'whomai'</span>);`就相当于`system(<span class=\"string\">'whoami'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mixed call_user_func( callable $callback [, mixed $parameter [, mixed $…]])<br>第一个参数<code>callback</code>是被调用的回调函数，其余参数是回调函数的参数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call_user_func(<span class=\"string\">'system'</span>,<span class=\"string\">'whoami'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mixed call_user_func_array( callable $callback, array $param_arr)<br>把第一个参数作为回调函数(callback)调用，把参数数组作(param_arr)为回调函数的参数传入</p>\n</li>\n</ul>\n<h2 id=\"包含函数\"><a href=\"#包含函数\" class=\"headerlink\" title=\"包含函数\"></a>包含函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span>、 <span class=\"keyword\">include</span>、 <span class=\"keyword\">require_once</span>、 <span class=\"keyword\">include_once</span></span><br></pre></td></tr></table></figure>\n<p>包含函数一共有四个，主要作用为包含并运行指定文件。<br><code>include</code> $file;<br>在变量 <code>$file</code>可控的情况下，我们就可以包含任意文件，从而达到<code>getshell</code>的目的。<br>另外，在不同的配置环境下，可以包含不同的文件。<br>因此又分为远程文件包含和本地文件包含。<br>包含函数也能够读取任意文件内容，这就需要用到【支持的协议和封装协议】和【过滤器】。<br>例如，利用PHP流<code>filter</code>读取任意文件<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span>($_GET[<span class=\"string\">'fiel'</span>]);</span><br><span class=\"line\">?file=php:<span class=\"comment\">//filter/convert.base64-encode/resource=index.php</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"命令执行函数\"><a href=\"#命令执行函数\" class=\"headerlink\" title=\"命令执行函数\"></a>命令执行函数</h2><ul>\n<li>exec()——执行一个外部程序</li>\n<li>passthru()——执行外部程序并且显示原始输出</li>\n<li>proc_open()——执行一个命令，并且打开用来输入/输出的文件指针</li>\n<li>shell_exec() &amp; `` ——通过shell环境执行命令，并且将完整的输出以字符串的方式返回。</li>\n<li>system()——执行外部程序，并且显示输出</li>\n<li>popen()——通过<code>popen()</code>的参数传递一条命令，并对<code>popen()</code>所打开的文件进行执行。</li>\n</ul>\n<p><strong>执行函数包括但不限于上述几个</strong></p>\n<p>同样的道理、只要命令的参数可控就够执行系统命令。<br>例如：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">system($cmd);</span><br><span class=\"line\"><span class=\"keyword\">or</span></span><br><span class=\"line\">system(<span class=\"string\">'ping -c 3'</span>.$target);</span><br></pre></td></tr></table></figure></p>\n<p>当<code>$cmd</code>可控就能执行任意命令，<br>而当<code>$target</code>可控的话，可以用管道符等特殊字符截断从而执行任意命令。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$target=<span class=\"string\">'a | whoami'</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"文件操作函数\"><a href=\"#文件操作函数\" class=\"headerlink\" title=\"文件操作函数\"></a>文件操作函数</h2><ul>\n<li>copy——拷贝文件</li>\n<li>file_get_contents —— 将整个文件读入一个字符串</li>\n<li>file_put_contents —— 将一个字符串写入文件</li>\n<li>file —— 把整个文件读入一个数组中</li>\n<li>fopen —— 打开文件或者 URL</li>\n<li>move_uploaded_file —— 将上传的文件移动到新位置</li>\n<li>readfile —— 输出文件</li>\n<li>rename —— 重命名一个文件或目录</li>\n<li>rmdir —— 删除目录</li>\n<li>unlink &amp; delete —— 删除文件</li>\n</ul>\n<p>任意文件读取、写入、删除往往是上面几个函数受到了控制（当然还有其他的函数）。<br>不同的函数在不同的场景有不同的作用和不同的利用手法。<br>读取： 可以读取配置等文件，拿到key<br>写入： 可以写入shell代码相关的内容<br>删除： 可以删除.lock文件而可以重新安装覆盖</p>\n<p><strong>更多思路请自行挖掘测试！！！</strong></p>\n<h2 id=\"特殊函数\"><a href=\"#特殊函数\" class=\"headerlink\" title=\"特殊函数\"></a>特殊函数</h2><ul>\n<li>信息泄露</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool phpinfo ([int $what = INFO_ALL])</span><br></pre></td></tr></table></figure>\n<p>输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path变量、配置选项的本地值和主值、HTTP头和PHP授权信息（License）。</p>\n<ul>\n<li>软连接-读取文件内容</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool symlink (string $target, string $link)</span><br></pre></td></tr></table></figure>\n<p><code>symlink()</code>对于已有的<code>target</code>建立一个名为<code>link</code>的符号连接。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string readlink (string $path)</span><br></pre></td></tr></table></figure></p>\n<p><code>readlink()</code>和同名的C函数做同样的事，返回符号链接的内容。</p>\n<ul>\n<li>环境变量</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string getenv (string $varname)</span><br></pre></td></tr></table></figure>\n<p>获取一个环境变量的值<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool putenv (string $setting)</span><br></pre></td></tr></table></figure></p>\n<p>添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。在请求结束时环境会恢复到初始状态。</p>\n<ul>\n<li>加载扩展</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool dl (string $library)</span><br></pre></td></tr></table></figure>\n<p>载入指定参数<code>library</code>的PHP扩展</p>\n<ul>\n<li>配置相关</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string ini_get (string $varname)</span><br></pre></td></tr></table></figure>\n<p>成功时返回配置选项的值。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string ini_set (string $varname, string $newvalue)</span><br><span class=\"line\">string ini_alter (string $varname, string $newvalue)</span><br></pre></td></tr></table></figure></p>\n<p>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void ini_restore (string $varname)</span><br></pre></td></tr></table></figure></p>\n<p>恢复指定的配置选项到它的原始值。</p>\n<ul>\n<li>数字判断</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool is_numeric (mixed $var)</span><br></pre></td></tr></table></figure>\n<p>如果<code>var</code>是数字和数字字符串则返回<code>TRUE</code>, 否则返回<code>FALSE</code>。<br>仅用<code>is_numeric</code>判断而不用<code>intval</code>转换就有可能插入16进制的字符串到数据库，进而可能导致sql二次注入。</p>\n<ul>\n<li>数组相关</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool in_array (mixed $needle, <span class=\"keyword\">array</span> $haystack [,bool $strict = <span class=\"keyword\">FALSE</span>])</span><br></pre></td></tr></table></figure>\n<p>在<code>haystack</code>中搜索<code>needle</code>,如果没有设置<code>strict</code>则使用宽松的比较。<br>该函数有一个特性，比较之前会进行自动类型转换。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"string\">'1abc'</span>;</span><br><span class=\"line\">in_array($a, <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)) <span class=\"comment\">// 返回 真</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>变量覆盖<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void parse_str (string $str [,<span class=\"keyword\">array</span> &amp;$arr])</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果<code>str</code>是URL传递入的查询字符串（query string）,则将它解析为变量并设置到当前作用域。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int extract (<span class=\"keyword\">array</span> &amp;$var_array [,int $extract_type = EXTR_OVERWRITE [, string $prefix = <span class=\"keyword\">NULL</span>]])</span><br></pre></td></tr></table></figure></p>\n<p>本函数用来将变量从数组中导入到当前的符号表中。检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool mb_parse_str (string $encoded_string [, <span class=\"keyword\">array</span> &amp;$result])</span><br></pre></td></tr></table></figure></p>\n<p>解析GET/POST/COOKIE数据并设置全局变量。由于PHP不提供原始POST/COOKIE数据，目前它仅能够用于GET数据。它解析了URL编码过的数据，检测其编码，并转换编码为内部编码，然后设置其值为<code>array</code>的<code>result</code>或者全局变量。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool import_request_variables (string $types [, string $prefix])</span><br></pre></td></tr></table></figure></p>\n<p>将GET/POST/COOKIE变量导入到全局作用域中。如果你禁止了<code>register_globals</code>,但又想用到一些全局变量，那么此函数就很有用。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$str = <span class=\"string\">\"first=value&amp;arr[]=foo+bar&amp;arr[]=baz\"</span>;</span><br><span class=\"line\">parse_str($str);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $first;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $arr[<span class=\"number\">0</span>]; <span class=\"comment\">// foo bar</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> $arr[<span class=\"number\">1</span>]; <span class=\"comment\">// baz</span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出：valuefoo barbaz</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>列目录</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">array</span> glob (string $pattern [,int $flags = <span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<p><code>glob()</code>函数依照<code>libc glob()</code>函数使用的规则寻找所有与<code>pattern</code>匹配的文件路径，类似于一般<code>shells</code>所用的规则一样。不进行缩写扩展或参数替代。</p>\n<ul>\n<li>无参数获取信息</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">array</span> get_defined_vars (void)</span><br></pre></td></tr></table></figure>\n<p>返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">array</span> get_defined_constants ([bool $categorize = <span class=\"keyword\">false</span>])</span><br></pre></td></tr></table></figure></p>\n<p>返回当前所有已定义的常量名和值。这包含<code>define()</code>函数所创建的,也包含了所有扩展所创建的。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">array</span> get_defined_functions (void)</span><br></pre></td></tr></table></figure></p>\n<p>返回一个包含所有已定义函数列表的多维数组<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">array</span> get_included_files (void)</span><br></pre></td></tr></table></figure></p>\n<p>返回所有被<code>include、include_once、require</code>和<code>require_once</code>的文件名</p>\n","text":"常见危险函数PHP代码执行函数mixed eval(string $code)把字符串 $code 作为PHP代码执行<br>很多常见的webshell都是用eval来执行具体操作的<br>比如：<br>1<br>&lt;?php @eval($_POST['cmd']);?&g","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","count":3,"path":"api/tags/PHP代码审计.json"}]},{"title":"多线程爬虫","slug":"多线程爬虫","date":"2019-01-27T09:53:12.000Z","updated":"2019-01-27T10:01:07.194Z","comments":true,"path":"api/articles/多线程爬虫.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"爬虫教程\"><a href=\"#爬虫教程\" class=\"headerlink\" title=\"爬虫教程\"></a>爬虫教程</h1><h2 id=\"多线程爬虫\"><a href=\"#多线程爬虫\" class=\"headerlink\" title=\"多线程爬虫\"></a>多线程爬虫</h2><p>有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用之前那种同步的方式下载。那效率肯会特别慢。这时候我们就可以考虑使用多线程的方式来下载图片。</p>\n<p><strong>多线程介绍：</strong><br>多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。<br>最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也可以有多节车厢。多线程的出现就是为了提高效率。同时它的出现也带来了一些问题。更多介绍请参考：<a href=\"https://baike.baidu.com/item/多线程/1190404?fr=aladdin\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/多线程/1190404?fr=aladdin</a></p>\n<p><strong>threading模块介绍：</strong><br>threading模块是python中专门提供用来做多线程编程的模块。threading模块中最常用的类是Thread。以下看一个简单的多线程程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">def coding():</span><br><span class=\"line\">    for x in range(3):</span><br><span class=\"line\">        print(&apos;%s正在写代码&apos; % x)</span><br><span class=\"line\">        time.sleep(1)</span><br><span class=\"line\"></span><br><span class=\"line\">def drawing():</span><br><span class=\"line\">    for x in range(3):</span><br><span class=\"line\">        print(&apos;%s正在画图&apos; % x)</span><br><span class=\"line\">        time.sleep(1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def single_thread():</span><br><span class=\"line\">    coding()</span><br><span class=\"line\">    drawing()</span><br><span class=\"line\"></span><br><span class=\"line\">def multi_thread():</span><br><span class=\"line\">    t1 = threading.Thread(target=coding)</span><br><span class=\"line\">    t2 = threading.Thread(target=drawing)</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.start()</span><br><span class=\"line\">    t2.start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    multi_thread()</span><br></pre></td></tr></table></figure>\n<p><strong>查看线程数：</strong><br>使用threading.enumerate()函数便可以看到当前线程的数量。</p>\n<p><strong>查看当前线程的名字：</strong><br>使用threading.current_thread()可以看到当前线程的信息。</p>\n<p><strong>继承自threading.Thread类：</strong><br>为了让线程代码更好的封装。可以使用threading模块下的Thread类，继承自这个类，然后实现run方法，线程就会自动运行run方法中的代码。示例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">class CodingThread(threading.Thread):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        for x in range(3):</span><br><span class=\"line\">            print(&apos;%s正在写代码&apos; % threading.current_thread())</span><br><span class=\"line\">            time.sleep(1)</span><br><span class=\"line\"></span><br><span class=\"line\">class DrawingThread(threading.Thread):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        for x in range(3):</span><br><span class=\"line\">            print(&apos;%s正在画图&apos; % threading.current_thread())</span><br><span class=\"line\">            time.sleep(1)</span><br><span class=\"line\"></span><br><span class=\"line\">def multi_thread():</span><br><span class=\"line\">    t1 = CodingThread()</span><br><span class=\"line\">    t2 = DrawingThread()</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.start()</span><br><span class=\"line\">    t2.start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    multi_thread()</span><br></pre></td></tr></table></figure></p>\n<p><strong>多线程共享全局变量的问题：</strong><br>多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。比如以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\"></span><br><span class=\"line\">tickets = 0</span><br><span class=\"line\"></span><br><span class=\"line\">def get_ticket():</span><br><span class=\"line\">    global tickets</span><br><span class=\"line\">    for x in range(1000000):</span><br><span class=\"line\">        tickets += 1</span><br><span class=\"line\">    print(&apos;tickets:%d&apos;%tickets)</span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    for x in range(2):</span><br><span class=\"line\">        t = threading.Thread(target=get_ticket)</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure></p>\n<p>以上结果正常来讲应该是6，但是因为多线程运行的不确定性。因此最后的结果可能是随机的。</p>\n<p><strong>锁机制：</strong><br>为了解决以上使用共享全局变量的问题。threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，直到当前线程处理完后，把锁释放了，其他线程才能进来处理。示例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\"></span><br><span class=\"line\">VALUE = 0</span><br><span class=\"line\"></span><br><span class=\"line\">gLock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">def add_value():</span><br><span class=\"line\">    global VALUE</span><br><span class=\"line\">    gLock.acquire()</span><br><span class=\"line\">    for x in range(1000000):</span><br><span class=\"line\">        VALUE += 1</span><br><span class=\"line\">    gLock.release()</span><br><span class=\"line\">    print(&apos;value：%d&apos;%VALUE)</span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    for x in range(2):</span><br><span class=\"line\">        t = threading.Thread(target=add_value)</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p><strong>Lock版本生产者和消费者模式：</strong><br>生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。以下是使用threading.Lock锁实现的“生产者与消费者模式”的一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import random</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">gMoney = 1000</span><br><span class=\"line\">gLock = threading.Lock()</span><br><span class=\"line\"># 记录生产者生产的次数，达到10次就不再生产</span><br><span class=\"line\">gTimes = 0</span><br><span class=\"line\"></span><br><span class=\"line\">class Producer(threading.Thread):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        global gMoney</span><br><span class=\"line\">        global gLock</span><br><span class=\"line\">        global gTimes</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            money = random.randint(100, 1000)</span><br><span class=\"line\">            gLock.acquire()</span><br><span class=\"line\">            # 如果已经达到10次了，就不再生产了</span><br><span class=\"line\">            if gTimes &gt;= 10:</span><br><span class=\"line\">                gLock.release()</span><br><span class=\"line\">                break</span><br><span class=\"line\">            gMoney += money</span><br><span class=\"line\">            print(&apos;%s当前存入%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class=\"line\">            gTimes += 1</span><br><span class=\"line\">            time.sleep(0.5)</span><br><span class=\"line\">            gLock.release()</span><br><span class=\"line\"></span><br><span class=\"line\">class Consumer(threading.Thread):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        global gMoney</span><br><span class=\"line\">        global gLock</span><br><span class=\"line\">        global gTimes</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            money = random.randint(100, 500)</span><br><span class=\"line\">            gLock.acquire()</span><br><span class=\"line\">            if gMoney &gt; money:</span><br><span class=\"line\">                gMoney -= money</span><br><span class=\"line\">                print(&apos;%s当前取出%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class=\"line\">                time.sleep(0.5)</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下</span><br><span class=\"line\">                if gTimes &gt;= 10:</span><br><span class=\"line\">                    gLock.release()</span><br><span class=\"line\">                    break</span><br><span class=\"line\">                print(&quot;%s当前想取%s元钱，剩余%s元钱，不足！&quot; % (threading.current_thread(),money,gMoney))</span><br><span class=\"line\">            gLock.release()</span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    for x in range(5):</span><br><span class=\"line\">        Consumer(name=&apos;消费者线程%d&apos;%x).start()</span><br><span class=\"line\"></span><br><span class=\"line\">    for x in range(5):</span><br><span class=\"line\">        Producer(name=&apos;生产者线程%d&apos;%x).start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p><strong>Condition版的生产者与消费者模式：</strong><br>Lock版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过while True死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。首先对threading.Condition相关的函数做个介绍，threading.Condition类似threading.Lock，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下将一些常用的函数做个简单的介绍：</p>\n<p>acquire：上锁。<br>release：解锁。<br>wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。<br>notify：通知某个正在等待的线程，默认是第1个等待的线程。<br>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。<br>Condition版的生产者与消费者模式代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import random</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">gMoney = 1000</span><br><span class=\"line\">gCondition = threading.Condition()</span><br><span class=\"line\">gTimes = 0</span><br><span class=\"line\">gTotalTimes = 5</span><br><span class=\"line\"></span><br><span class=\"line\">class Producer(threading.Thread):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        global gMoney</span><br><span class=\"line\">        global gCondition</span><br><span class=\"line\">        global gTimes</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            money = random.randint(100, 1000)</span><br><span class=\"line\">            gCondition.acquire()</span><br><span class=\"line\">            if gTimes &gt;= gTotalTimes:</span><br><span class=\"line\">                gCondition.release()</span><br><span class=\"line\">                print(&apos;当前生产者总共生产了%s次&apos;%gTimes)</span><br><span class=\"line\">                break</span><br><span class=\"line\">            gMoney += money</span><br><span class=\"line\">            print(&apos;%s当前存入%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class=\"line\">            gTimes += 1</span><br><span class=\"line\">            time.sleep(0.5)</span><br><span class=\"line\">            gCondition.notify_all()</span><br><span class=\"line\">            gCondition.release()</span><br><span class=\"line\"></span><br><span class=\"line\">class Consumer(threading.Thread):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        global gMoney</span><br><span class=\"line\">        global gCondition</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            money = random.randint(100, 500)</span><br><span class=\"line\">            gCondition.acquire()</span><br><span class=\"line\">            # 这里要给个while循环判断，因为等轮到这个线程的时候</span><br><span class=\"line\">            # 条件有可能又不满足了</span><br><span class=\"line\">            while gMoney &lt; money:</span><br><span class=\"line\">                if gTimes &gt;= gTotalTimes:</span><br><span class=\"line\">                    gCondition.release()</span><br><span class=\"line\">                    return</span><br><span class=\"line\">                print(&apos;%s准备取%s元钱，剩余%s元钱，不足！&apos;%(threading.current_thread(),money,gMoney))</span><br><span class=\"line\">                gCondition.wait()</span><br><span class=\"line\">            gMoney -= money</span><br><span class=\"line\">            print(&apos;%s当前取出%s元钱，剩余%s元钱&apos; % (threading.current_thread(), money, gMoney))</span><br><span class=\"line\">            time.sleep(0.5)</span><br><span class=\"line\">            gCondition.release()</span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    for x in range(5):</span><br><span class=\"line\">        Consumer(name=&apos;消费者线程%d&apos;%x).start()</span><br><span class=\"line\"></span><br><span class=\"line\">    for x in range(2):</span><br><span class=\"line\">        Producer(name=&apos;生产者线程%d&apos;%x).start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p><strong>Queue线程安全队列：</strong><br>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做queue模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下：</p>\n<p>初始化Queue(maxsize)：创建一个先进先出的队列。<br>qsize()：返回队列的大小。<br>empty()：判断队列是否为空。<br>full()：判断队列是否满了。<br>get()：从队列中取最后一个数据。<br>put()：将一个数据放到队列中。<br>使用生产者与消费者模式多线程下载表情包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import requests</span><br><span class=\"line\">from lxml import etree</span><br><span class=\"line\">from urllib import request</span><br><span class=\"line\">import os</span><br><span class=\"line\">import re</span><br><span class=\"line\">from queue import Queue</span><br><span class=\"line\"></span><br><span class=\"line\">class Producer(threading.Thread):</span><br><span class=\"line\">    headers = &#123;</span><br><span class=\"line\">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    def __init__(self,page_queue,img_queue,*args,**kwargs):</span><br><span class=\"line\">        super(Producer, self).__init__(*args,**kwargs)</span><br><span class=\"line\">        self.page_queue = page_queue</span><br><span class=\"line\">        self.img_queue = img_queue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            if self.page_queue.empty():</span><br><span class=\"line\">                break</span><br><span class=\"line\">            url = self.page_queue.get()</span><br><span class=\"line\">            self.parse_page(url)</span><br><span class=\"line\"></span><br><span class=\"line\">    def parse_page(self,url):</span><br><span class=\"line\">        response = requests.get(url,headers=self.headers)</span><br><span class=\"line\">        text = response.text</span><br><span class=\"line\">        html = etree.HTML(text)</span><br><span class=\"line\">        imgs = html.xpath(&quot;//div[@class=&apos;page-content text-center&apos;]//a//img&quot;)</span><br><span class=\"line\">        for img in imgs:</span><br><span class=\"line\">            if img.get(&apos;class&apos;) == &apos;gif&apos;:</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            img_url = img.xpath(&quot;.//@data-original&quot;)[0]</span><br><span class=\"line\">            suffix = os.path.splitext(img_url)[1]</span><br><span class=\"line\">            alt = img.xpath(&quot;.//@alt&quot;)[0]</span><br><span class=\"line\">            alt = re.sub(r&apos;[，。？?,/\\\\·]&apos;,&apos;&apos;,alt)</span><br><span class=\"line\">            img_name = alt + suffix</span><br><span class=\"line\">            self.img_queue.put((img_url,img_name))</span><br><span class=\"line\"></span><br><span class=\"line\">class Consumer(threading.Thread):</span><br><span class=\"line\">    def __init__(self,page_queue,img_queue,*args,**kwargs):</span><br><span class=\"line\">        super(Consumer, self).__init__(*args,**kwargs)</span><br><span class=\"line\">        self.page_queue = page_queue</span><br><span class=\"line\">        self.img_queue = img_queue</span><br><span class=\"line\"></span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            if self.img_queue.empty():</span><br><span class=\"line\">                if self.page_queue.empty():</span><br><span class=\"line\">                    return</span><br><span class=\"line\">            img = self.img_queue.get(block=True)</span><br><span class=\"line\">            url,filename = img</span><br><span class=\"line\">            request.urlretrieve(url,&apos;images/&apos;+filename)</span><br><span class=\"line\">            print(filename+&apos;  下载完成！&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    page_queue = Queue(100)</span><br><span class=\"line\">    img_queue = Queue(500)</span><br><span class=\"line\">    for x in range(1,101):</span><br><span class=\"line\">        url = &quot;http://www.doutula.com/photo/list/?page=%d&quot; % x</span><br><span class=\"line\">        page_queue.put(url)</span><br><span class=\"line\"></span><br><span class=\"line\">    for x in range(5):</span><br><span class=\"line\">        t = Producer(page_queue,img_queue)</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    for x in range(5):</span><br><span class=\"line\">        t = Consumer(page_queue,img_queue)</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure></p>\n<p><strong>GIL全局解释器锁：</strong><br>Python自带的解释器是CPython。CPython解释器的多线程实际上是一个假的多线程（在多核CPU中，只能利用一核，不能利用多核）。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中有一个东西叫做GIL（Global Intepreter Lock），叫做全局解释器锁。这个解释器锁是有必要的。因为CPython解释器的内存管理不是线程安全的。当然除了CPython解释器，还有其他的解释器，有些解释器是没有GIL锁的，见下面：</p>\n<p>Jython：用Java实现的Python解释器。不存在GIL锁。更多详情请见：<a href=\"https://zh.wikipedia.org/wiki/Jython\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Jython</a><br>IronPython：用.net实现的Python解释器。不存在GIL锁。更多详情请见：<a href=\"https://zh.wikipedia.org/wiki/IronPython\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/IronPython</a><br>PyPy：用Python实现的Python解释器。存在GIL锁。更多详情请见：<a href=\"https://zh.wikipedia.org/wiki/PyPy\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/PyPy</a><br>GIL虽然是一个假的多线程。但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。<br>多线程下载百思不得姐段子作业：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import requests</span><br><span class=\"line\">from lxml import etree</span><br><span class=\"line\">import threading</span><br><span class=\"line\">from queue import Queue</span><br><span class=\"line\">import csv</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class BSSpider(threading.Thread):</span><br><span class=\"line\">    headers = &#123;</span><br><span class=\"line\">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    def __init__(self,page_queue,joke_queue,*args,**kwargs):</span><br><span class=\"line\">        super(BSSpider, self).__init__(*args,**kwargs)</span><br><span class=\"line\">        self.base_domain = &apos;http://www.budejie.com&apos;</span><br><span class=\"line\">        self.page_queue = page_queue</span><br><span class=\"line\">        self.joke_queue = joke_queue</span><br><span class=\"line\"></span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            if self.page_queue.empty():</span><br><span class=\"line\">                break</span><br><span class=\"line\">            url = self.page_queue.get()</span><br><span class=\"line\">            response = requests.get(url, headers=self.headers)</span><br><span class=\"line\">            text = response.text</span><br><span class=\"line\">            html = etree.HTML(text)</span><br><span class=\"line\">            descs = html.xpath(&quot;//div[@class=&apos;j-r-list-c-desc&apos;]&quot;)</span><br><span class=\"line\">            for desc in descs:</span><br><span class=\"line\">                jokes = desc.xpath(&quot;.//text()&quot;)</span><br><span class=\"line\">                joke = &quot;\\n&quot;.join(jokes).strip()</span><br><span class=\"line\">                link = self.base_domain+desc.xpath(&quot;.//a/@href&quot;)[0]</span><br><span class=\"line\">                self.joke_queue.put((joke,link))</span><br><span class=\"line\">            print(&apos;=&apos;*30+&quot;第%s页下载完成！&quot;%url.split(&apos;/&apos;)[-1]+&quot;=&quot;*30)</span><br><span class=\"line\"></span><br><span class=\"line\">class BSWriter(threading.Thread):</span><br><span class=\"line\">    headers = &#123;</span><br><span class=\"line\">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, joke_queue, writer,gLock, *args, **kwargs):</span><br><span class=\"line\">        super(BSWriter, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        self.joke_queue = joke_queue</span><br><span class=\"line\">        self.writer = writer</span><br><span class=\"line\">        self.lock = gLock</span><br><span class=\"line\"></span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                joke_info = self.joke_queue.get(timeout=40)</span><br><span class=\"line\">                joke,link = joke_info</span><br><span class=\"line\">                self.lock.acquire()</span><br><span class=\"line\">                self.writer.writerow((joke,link))</span><br><span class=\"line\">                self.lock.release()</span><br><span class=\"line\">                print(&apos;保存一条&apos;)</span><br><span class=\"line\">            except:</span><br><span class=\"line\">                break</span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    page_queue = Queue(10)</span><br><span class=\"line\">    joke_queue = Queue(500)</span><br><span class=\"line\">    gLock = threading.Lock()</span><br><span class=\"line\">    fp = open(&apos;bsbdj.csv&apos;, &apos;a&apos;,newline=&apos;&apos;, encoding=&apos;utf-8&apos;)</span><br><span class=\"line\">    writer = csv.writer(fp)</span><br><span class=\"line\">    writer.writerow((&apos;content&apos;, &apos;link&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    for x in range(1,11):</span><br><span class=\"line\">        url = &apos;http://www.budejie.com/text/%d&apos; % x</span><br><span class=\"line\">        page_queue.put(url)</span><br><span class=\"line\"></span><br><span class=\"line\">    for x in range(5):</span><br><span class=\"line\">        t = BSSpider(page_queue,joke_queue)</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    for x in range(5):</span><br><span class=\"line\">        t = BSWriter(joke_queue,writer,gLock)</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>","text":"爬虫教程多线程爬虫有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用之前那种同步的方式下载。那效率肯会特别慢。这时候我们就可以考虑使用多线程的方式来下载图片。多线程介绍：<br>多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"python_爬虫","slug":"python-爬虫","count":1,"path":"api/tags/python-爬虫.json"}]},{"title":"app中的加密与解密","slug":"app中的加密与解密","date":"2019-01-21T09:26:19.000Z","updated":"2019-01-21T10:00:00.157Z","comments":true,"path":"api/articles/app中的加密与解密.json","excerpt":"","keywords":null,"cover":"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/APP逆向/app_raw.png","content":"<h2 id=\"App渗透中常见的加密与解密\"><a href=\"#App渗透中常见的加密与解密\" class=\"headerlink\" title=\"App渗透中常见的加密与解密\"></a>App渗透中常见的加密与解密</h2><pre><code>本文主要介绍了目前App数据传输过程中几种常见的加密方式，以及一些常规的解密手段，并不涵盖并应对所有情况，在实战过程中还须具体情况具体分析，随机应变；（注：全文中所提到的App仅针对Android App）\n</code></pre><p>随着App移动应用的广泛应用及移动开发技术的飞速发展，移动应用的安全也越来越被重视；<br>在App服务端渗透中，我们在抓包时经常会发现App在数据传输过程中做了加密（如图1），以防止数据被查看或被篡改；<br>而渗透过程中的很多时候我们都需要抓包修改，这就要求我们需要先对App数据包进行解密了。</p>\n<h3 id=\"一些常见的加密方式\"><a href=\"#一些常见的加密方式\" class=\"headerlink\" title=\"一些常见的加密方式\"></a>一些常见的加密方式</h3><p>对于App传输数据加密，一般会考虑三个方面:<br>1）可用性：客户端和服务端都可逆向破解<br>2）较高的安全性：不容易被破解<br>3）效率性：加密性能及资源占用方面不是很高</p>\n<p>针对以上三个方面需求，目前用得最多有以下几种加密方式（当然，有时候会掺杂一些其他的小算法，具体情况自行识别和解码即可），其特点及优缺点分别阐述如下。</p>\n<p>1）对称性加密。如DES、AES、3DES等。这些加密方式的算法基本已公开，因此其特点为密钥/生成密钥的方法固定，因此这种加密方式的优点为性能效率较好，而且也较大的提升了解密的成本；但由于密钥固定，因此缺点也很明显了，则是在客户端和服务端上都能找到密钥或密钥的生成方法。因此其突破口为通过逆向客户端来寻找密钥。另外，这种加密方式可同时用于请求包和返回包。</p>\n<p>2）非对称性加密。如RSA、Rabin等。这些加密方式的算法基本也已经公开，因此其特点为有一对公钥和私钥：客户端上保存公钥，用于加密；服务端上保存私钥，用于解密。因此这种加密方式的优点为安全性较高，客户端上只有用于加密的公钥，而没有用于解密的私钥；而弱点则为加解密效率不高，性能资源占用较大，所以目前很多App还是选用对称性加密。由于客户端上没有解密数据包的私钥，因此需要使用其他方法获取数据包明文才能进行数据包篡改。（获取方法后续详述）另外，由于只有一对公钥和私钥，所以这种加密方式一般只会出现在请求包，而返回包则一般为明文返回。</p>\n<p>3）自定义算法加密。有少数App开发的技术人员还会使用自定义算法来对数据包进行加密，算法五花八门，大多为各种常见的编码（如Base64）和字节位移运算等混杂。这种加密方式的优点为效率较高，但缺点为算法硬编码在客户端中，只要通过逆向即可解密出来。</p>\n<p>以上三种加密方式各有优缺点，对于第一和第三种，虽说可通过逆向App获取密钥/算法来进行解密，但是开发者往往会通过其他手段来增强安全性，如App加固或把密钥/算法硬编码在so文件中等；这样就更进一步地提高了逆向与解密的难度和成本了。</p>\n<h3 id=\"常规的解密手段\"><a href=\"#常规的解密手段\" class=\"headerlink\" title=\"常规的解密手段\"></a>常规的解密手段</h3><ul>\n<li>判断加密方式</li>\n</ul>\n<p>对于解密，首先我们须要先大概判断使用的是什么样的加密方式，不管是对称还是非对称加密，从这些加密算法的密文形式可知，一般只有以下三种：</p>\n<p>1）原始格式。也就是字节数组了，这种展现在数据包中就是乱码了。</p>\n<p><img src=\"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/APP逆向/app_raw.png\" alt=\"\"></p>\n<p>2）十六进制，亦即Hex编码。对称/非对称加密后，做了Hex编码处理（如图3）</p>\n<p><img src=\"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/APP逆向/app_hex.png\" alt=\"\"></p>\n<p>3）Base64编码样式，对称/非对称加密后，做了Base64编码处理（如图4）</p>\n<p><img src=\"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/APP逆向/app_base.png\" alt=\"\"></p>\n<p>综上，如果发现数据包是这三种形式，而且尝试过Base64反编码后是乱码的，那很大概率就是使用了对称/非对称性加密了；<br>而对于自定义算法加密的，一来并不常见，二来很多时候密文形式会比较奇葩，所以最后考虑。</p>\n<p>当判断出是对称/非对称加密时，我们可以进一步判断用的是对称还是非对称。<br>判断方法比较多，最简单的一个方法是，对于同一个数据请求包，重复触发时，<br>密文是一模一样的则为对称性加密，而密文不一样的则为非对称性加密了。</p>\n<ul>\n<li>定位密钥/算法代码</li>\n</ul>\n<p>接着，我们需要通过逆向App来寻找对称/非对称性加密的密钥。<br>逆向后，得到的是java代码及对应的Smali代码。<br>一般地，前者用于分析，后者用于调试。<br>我们先在java代码中查找并定位到加密过程的代码。<br>如何定位？一言以蔽之：全靠眼和经验。<br>比如可以在整个class包中查找含有加密数据包的url接口所在的位置，然后一步步跟踪查看其加密数据是通过什么函数生成的，最终定位到加密函数，当然中间的函数跳转可能会很多；又如可以暴力地直接在整个class包中查找加密函数的一些关键字，如AES、DES之类的，当然这样返回的结果可能会很多，只要一个个验证过去就可以了。至于如何验证，我们可以通过经验去判断，也可以通过下面所讲的调试。</p>\n<ul>\n<li>调试</li>\n</ul>\n<blockquote>\n<p>第一种</p>\n</blockquote>\n<p>正如开发编程一样，调试往往是程序定位的最好方法。而调试有两种方法，一为日志输出，二为动态调试。<br>举个例子，比如我们在java代码查找中找到一段DES的加密函数代码，不确定是否数据包加密时所调用的，<br>这时我们可以在Smali代码里该函数中插入日志输出代码，如<br><code>const-string v0, &quot;Log here！！！！！！！&quot;</code><br><code>invoke-static {v0, v0}, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I</code><br>保存后编译回apk文件，并在手机/模拟器中安装后打开App触发加密数据包，<br>并通过<code>adb logcat</code>输出日志，查看是否有<code>“Log here!!!!!!”。</code>如果有则说明加密函数代码定位成功；反之则失败。</p>\n<blockquote>\n<p>第二种</p>\n</blockquote>\n<p>当然，我们也可以使用动态调试法来解决上面的例子。<br>将反编译后的App文件夹载入到开发环境中（如Eclipse等），<br>记得先修改AndroidManifest.xml开启调试模式，<br>然后在Smali代码里该函数开头处设置断点，<br>并在开发环境所连接的Android模拟器中启动App触发加密数据包，<br>即可通过查看是否停在断点出来进行判断。</p>\n<ul>\n<li>获取密钥/算法</li>\n</ul>\n<blockquote>\n<p>一</p>\n</blockquote>\n<p>当定位到加密函数后，算法已经展示在面前了。<br>而密钥的话，我们可以继续使用调试方法来获取密钥。<br>如果使用日志输出法的话，有时候密钥不一定是字符串格式，直接日志输出时会报错，<br>所以我们切记一定要在Smali代码中把密钥的对应参数类型转换为字符串格式；<br>如果使用动态调试法的话，开发环境中走到密钥寄存器那一步时会则自动显示出来。</p>\n<blockquote>\n<p>二</p>\n</blockquote>\n<p>对于对称性加密和自定义算法加密的，<br>当获取到加密密钥/算法时，我们已经可以直接解密数据包获取明文–篡改明文数据包（如加入注入/xss攻击字符串）–加密明文数据包为密文–发送了；<br>而对于非对称性加密，<br>由于客户端中只有公钥，因此只能做篡改数据包后的加密动作，而无法直接解密数据包；<br>此时，我们可以使用其他方法来获取数据包明文，比如使用调试同理把加密前的数据包明文参数获取即可~</p>\n<h3 id=\"防御手段\"><a href=\"#防御手段\" class=\"headerlink\" title=\"防御手段\"></a>防御手段</h3><p>没有绝对的安全，预防往往是建立在不断提高攻击成本和难度的基础上。<br>针对上述常规的解密手段，我们可以从以下方面来增强App加密的安全性。</p>\n<p>1）App加固。使用加壳、混淆等手段，增强App被反编译的难度和成本。</p>\n<p>2）使用So文件来保存密钥/算法。由于So文件是c编译的，因此反编译的难度无疑增大了很多。</p>\n<p>3）重要的核心业务App考虑使用加密WAF。一般经过加密后的App，WAF基本已经失去检测和防御作用了；<br>因此，对于重要的核心业务App，可考虑把加密模块加到WAF中，以保持检测防御效果。</p>\n","text":"App渗透中常见的加密与解密本文主要介绍了目前App数据传输过程中几种常见的加密方式，以及一些常规的解密手段，并不涵盖并应对所有情况，在实战过程中还须具体情况具体分析，随机应变；（注：全文中所提到的App仅针对Android App）随着App移动应用的广泛应用及移动开发技术的飞","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"App","slug":"App","count":1,"path":"api/tags/App.json"}]},{"title":"CTF线下赛总结","slug":"CTF线下赛总结","date":"2019-01-03T07:21:43.000Z","updated":"2019-01-03T09:07:12.905Z","comments":true,"path":"api/articles/CTF线下赛总结.json","excerpt":"<h1 id=\"CTF线下攻防赛\"><a href=\"#CTF线下攻防赛\" class=\"headerlink\" title=\"CTF线下攻防赛\"></a>CTF线下攻防赛</h1>","keywords":null,"cover":"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/CTF/1707042315cda976443f9eca49.png","content":null,"text":"CTF线下攻防赛 [Figure] http://www.freebuf.com/articles/web/96675.html总结CTF能够给不能层次的人在技术上带来提高。没有网络信息安全基础的学生通过CTF，建立了安全攻防的概念；有初步基础的学生，通过高质量赛题的实践练习，提","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CTF思路","slug":"CTF思路","count":1,"path":"api/tags/CTF思路.json"}]},{"title":"去火","slug":"去火","date":"2018-12-18T08:07:17.000Z","updated":"2018-12-26T03:31:59.462Z","comments":true,"path":"api/articles/去火.json","excerpt":"<h1 id=\"去火\"><a href=\"#去火\" class=\"headerlink\" title=\"去火\"></a>去火</h1><pre><code>本来这是技术博客，为什么写一篇关于去火的文章那？安全这个行业，表面\n上看着挺轻松的，其实也是经常熬夜的。最近上火，每天晚上失眠，折腾我\n差不多一个月了。以此文提醒自己，工作的同时，也不要忘记健康。\n</code></pre>","keywords":null,"cover":null,"content":null,"text":"去火本来这是技术博客，为什么写一篇关于去火的文章那？安全这个行业，表面上看着挺轻松的，其实也是经常熬夜的。最近上火，每天晚上失眠，折腾我差不多一个月了。以此文提醒自己，工作的同时，也不要忘记健康。去火速查表序列对应的部位症状治疗对策1肺火干咳无痰或痰少而粘、潮热盗汗、手足心热、失","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"健康","slug":"健康","count":1,"path":"api/tags/健康.json"}]},{"title":"py版netcat","slug":"py版netcat","date":"2018-12-16T04:17:39.000Z","updated":"2018-12-22T13:01:30.796Z","comments":true,"path":"api/articles/py版netcat.json","excerpt":"<h1 id=\"python-版-nc\"><a href=\"#python-版-nc\" class=\"headerlink\" title=\"python 版 nc\"></a>python 版 nc</h1><pre><code>最近在啃《Python 黑帽子：黑客与渗透测试编程之道》这本书，书中提到用py写一个替代nc的工具。\n比这写了一边，发现不能用，毕竟太久远了。后来去网上各种搜，已经后很多人写了，谷歌百度大\n概看了十来个。有一点可以肯定：都是把原著照搬下来，然后用subprocess换个命令行。找了俩个\n正规的下载下来试了下。。。跑不起来，可能是我能力有限。好吧，只能自己写了。\n</code></pre>","keywords":null,"cover":"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/python/netcat_falg.png","content":null,"text":"python 版 nc最近在啃《Python 黑帽子：黑客与渗透测试编程之道》这本书，书中提到用py写一个替代nc的工具。比这写了一边，发现不能用，毕竟太久远了。后来去网上各种搜，已经后很多人写了，谷歌百度大概看了十来个。有一点可以肯定：都是把原著照搬下来，然后用subproce","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"python-工具","slug":"python-工具","count":1,"path":"api/tags/python-工具.json"}]},{"title":"网络编程入门","slug":"网络编程入门","date":"2018-12-13T08:01:42.000Z","updated":"2018-12-13T08:16:44.950Z","comments":true,"path":"api/articles/网络编程入门.json","excerpt":"<h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1>","keywords":null,"cover":"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/python/socket_yanshi.png","content":null,"text":"客户端1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br># -*- coding: utf-8 -*-<br><br>import socket<br><b","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"python-网络","slug":"python-网络","count":1,"path":"api/tags/python-网络.json"}]},{"title":"NMAP脚本NSE的使用","slug":"NMAP脚本NSE的使用","date":"2018-12-10T02:51:12.000Z","updated":"2018-12-22T13:02:25.089Z","comments":true,"path":"api/articles/NMAP脚本NSE的使用.json","excerpt":"<h1 id=\"nmap加载nse脚本在内网渗透中的使用\"><a href=\"#nmap加载nse脚本在内网渗透中的使用\" class=\"headerlink\" title=\"nmap加载nse脚本在内网渗透中的使用\"></a>nmap加载nse脚本在内网渗透中的使用</h1><pre><code>大部分时间我们都用nmap来做端口扫描，其实它还可以进行攻击尝试。\n</code></pre>","keywords":null,"cover":"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/内网渗透/nmap_pei.png","content":null,"text":"nmap加载nse脚本在内网渗透中的使用大部分时间我们都用nmap来做端口扫描，其实它还可以进行攻击尝试。 [Figure] 参考http://www.mottoin.com/sole/topic/85401.html","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","count":5,"path":"api/tags/内网渗透.json"}]},{"title":"内网 ARP简单了解","slug":"内网-ARP简单了解","date":"2018-12-08T12:34:53.000Z","updated":"2018-12-22T12:59:35.752Z","comments":true,"path":"api/articles/内网-ARP简单了解.json","excerpt":"<h1 id=\"内网-ARP\"><a href=\"#内网-ARP\" class=\"headerlink\" title=\"内网 ARP\"></a>内网 ARP</h1>","keywords":null,"cover":"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/内网渗透/ARP_tu.png","content":null,"text":"内网 ARP [Figure] 推荐一个 arp 讲解的帖子，写的很好：图解ARP协议（一）图解ARP协议（二）ARP攻击篇图解ARP协议（三）ARP防御篇-如何揪出”内鬼”并”优雅的还手”?图解ARP协议（四）代理ARP：善意的欺骗图解ARP协议（五）免费ARP：地址冲突了肿么","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","count":5,"path":"api/tags/内网渗透.json"}]},{"title":"内网定位总结","slug":"内网定位总结","date":"2018-12-06T13:39:52.000Z","updated":"2018-12-22T12:44:26.497Z","comments":true,"path":"api/articles/内网定位总结.json","excerpt":"<h1 id=\"内网渗透测试定位技术总结\"><a href=\"#内网渗透测试定位技术总结\" class=\"headerlink\" title=\"内网渗透测试定位技术总结\"></a>内网渗透测试定位技术总结</h1><h2 id=\"服务器（机器）定位\"><a href=\"#服务器（机器）定位\" class=\"headerlink\" title=\"服务器（机器）定位\"></a>服务器（机器）定位</h2>","keywords":null,"cover":"https://bj.bcebos.com/v1/image-langke/hexo-neirongpeitu/内网渗透/组织结构_.png","content":null,"text":"内网渗透测试定位技术总结服务器（机器）定位收集域以及域内用户信息收集域内域控制器信息收集域控上域用户登录登录日志信息收集域内所有用户名以及全名、备注等信息收集域内工作组信息收集域管理员账号信息收集域内网段划分信息收集域内组织单位信息常用命令net view查看域内用户列表<br>","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"内网渗透","slug":"内网渗透","count":5,"path":"api/tags/内网渗透.json"}]}]}